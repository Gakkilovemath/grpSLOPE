% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/grpslope.R
\name{lambdaGroupSLOPE}
\alias{lambdaGroupSLOPE}
\title{Regularizing sequence for Group SLOPE}
\usage{
lambdaGroupSLOPE(method, fdr, group, wt, n.obs = NULL)
}
\arguments{
\item{method}{Possible values are "max", "mean",
and "corrected". See under Details.}

\item{fdr}{Target group false discovery rate (gFDR)}

\item{group}{A vector describing the grouping structure. It should 
contain a group id for each predictor variable.}

\item{wt}{A named vector of weights, one weight per group of predictors
(named according to names as in vector \code{group})}

\item{n.obs}{Number of observations (i.e., number of rows in \code{A});
required only if method is "corrected"}
}
\description{
Generate the regularizing sequence \code{lambda} for the Group SLOPE
problem according to one of multiple methods (see Details).
}
\details{
Multiple methods are available to generate the regularizing sequence \code{lambda}:
\itemize{
  \item "max" -- lambdas as in Theorem 2.5 in Brzyski et. al. (2015).
    Provalby controls gFDR in orthogonal designs.
  \item "mean" -- lambdas of equation (2.14) in Brzyski et. al. (2015)
    Applicable for gFDR control in orthogonal designs. Less conservative than "max".
  \item "corrected" -- lambdas of Procedure 1 in Brzyski et. al. (2015) if all 
    group sizes are equal and \code{wt} is a constant vector; otherwise, lambdas
    of Procedure 2 in Brzyski et. al. (2015).
    Applicable for gFDR control when predictors from different groups are stochastically independent.
}
}
\examples{
#TODO: rework the examples
fdr     <- 0.1
n.obs   <- 700
n.group <- 90
# generate 90 groups of sizes 5, 10, and 20
group   <- vector()
for (i in 1:30) {
  tmp <- rep((i-1)*3+c(1,2,3), c(5,10,20))
  group <- c(group, tmp)
}
# set the weight for each group to the square root of the group's size
wt <- rep(c(sqrt(5), sqrt(10), sqrt(20)), 30)
names(wt) <- names(getGroupID(group))
# compute different lambda sequences
lambda.max <- lambdaGroupSLOPE(fdr=fdr, group=group, wt=wt, method="max") 
lambda.mean <- lambdaGroupSLOPE(fdr=fdr, group=group, wt=wt, method="mean") 
lambda.chi <- lambdaGroupSLOPE(fdr=fdr, n.obs=n.obs, group=group, wt=wt, method="chiMean")

}
\references{
D. Brzyski, W. Su, M. Bogdan (2015), \emph{Group SLOPE -- adaptive selection of groups of predictors}, \url{http://arxiv.org/abs/1511.09078}
}

